## Runtime Best Practices

- **Load order matters.** `nba_jam.js` defers to `lib/core/module-loader.js`, which loads hundreds of modules in a deliberate sequence (core BBS libs → error handling → constants → systems → rendering → logic → AI → multiplayer). Any new module should either be injected via that loader or explicitly document its relative ordering needs so dependent globals already exist (for example `COURT_WIDTH` is validated immediately after `lib/utils/constants.js` is loaded).
- **Centralize dependencies through `initializeSystems`.** The Wave‑23 rewrite expects every new system to be constructed inside `lib/core/system-init.js` by feeding it `stateManager`, `eventBus`, `frameScheduler`, and the helper bundle. Attaching ad-hoc globals outside that file makes the dependency graph opaque and breaks multiplayer, which reuses the same systems instance.
- **Use the state manager instead of raw globals.** `createStateManager` wraps the mutable `gameState` object and provides traceable `set(key, value, reason)` updates. When code bypasses it (e.g., writing directly to `teamAPlayer1`), multiplayer synchronization and replay tools lose the audit trail that runGameFrame expects.
- **Respect layered rendering.** `initFrames` creates separate frames for court, trail overlays, hoop sprites, announcer text, and the scoreboard. Visual effects (jump indicators, fire trails, temporary HUDs) should target `trailFrame` or dedicated overlays rather than painting onto `courtFrame`, so cleanup is as cheap as closing a frame.
- **Throttle expensive logic through config.** `getSinglePlayerTempo()` and `TIMING_CONSTANTS` define the canonical `frameDelayMs`, `aiIntervalMs`, shove cooldowns, etc. New subsystems should pull values from those config objects so both single-player and multiplayer cadence stay in sync.
- **Guard console I/O.** Many helpers assume a real BBS console is available, but automated tests and coordinator instances often run headless. Follow the pattern used in `initFrames` (`if (typeof console !== 'undefined' && typeof console.clear === 'function')`) before calling any console API.

## Architectural Practices

- **Keep logic inside `runGameFrame`.** The unified game loop (lib/core/game-loop-core.js) owns clock ticks, AI throttling, physics, rendering cadence, and violation handling. Per-frame behaviors should hook into that function via events or helpers instead of spinning their own loops.
- **Exploit the event bus.** `initializeSystems` wires shared behavior (e.g., possession changes, pass completions) through `eventBus`. Publishing new gameplay events there keeps UI, stats, and multiplayer coordinators decoupled.
- **Mirror authority logic on the client only when necessary.** Multiplayer prediction code in `mp_client.js` mirrors a simplified version of `applyMovementCommand` purely to give the player a snappy feel; the authoritative coordinator always re-simulates moves with the real physics modules. Any fixes to movement or collision routines should also be reflected in the prediction helpers to prevent rubber-banding.
- **Prefer helper modules over inline math.** Court geometry, shoe colors, AI heuristics, and turbo behavior now live in shared config modules (`lib/config/*.js`). Pull from those modules instead of scattering literals like `COURT_WIDTH - 7` or `Math.random() < 0.35` through the codebase.
- **Document every cross-module dependency.** When a module leans on another module's globals, add a comment near the top (see the header comments in `lib/game-logic/physical-play.js`). This makes it obvious which files must be loaded first and helps the module loader catch missing dependencies early.

## Debugging & Instrumentation

- **Use the provided loggers.** `debugLog`, `logError`, and `logErrorWithSnapshot` are loaded during initialization and already understand the BBS environment. Writing straight to `console` during asynchronous multiplayer paths can deadlock input queues.
- **Leverage state snapshots.** Many systems (`game-loop-core`, `physical-play`, `mp_client`) set specific stateManager keys when something unexpected happens. Inspecting those keys (“ballCarrierNeedsDecision”, “inboundPassData”, “reboundActive”) is faster than scattering new print statements.
- **Keep coordinator/client logs separate.** Multiplayer code writes coordinator output to `data/debug.log` and client prediction output to standard log channels. Follow that pattern so local debugging doesn’t pollute shared server logs. (DEV NOTE: I don't think this is a best practice, there's no harm in using the shared data/debug.log as long as things are labeled, and it saves time because you can't parse console output, but files are easy)

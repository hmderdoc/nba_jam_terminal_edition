## Known Issues (Current Code Survey)

1. **Trail frame dependency for jump indicators.** `lib/rendering/jump-indicators.js` now hard-requires `trailFrame`. If `initFrames` ever fails to create or open the overlay (e.g., headless test harness that only opens `courtFrame`), jump indicators simply do nothing. We have no fallback or warning, so users could lose all block/landing feedback without understanding why.
2. **Betting hotkey during single-player matchups.** We intentionally disabled prompts (`GAME_MODE_CONSTANTS.BETTING.promptsEnabled = false`) but still allow `[B]` in all contexts (`BETTING.hotkeyEnabled = true`). In non-demo single-player games that may confuse players because the feature silently exists without affordance.
3. **`gameLoop` keyboard polling assumes local console.** The single-player `handleInput` callback calls `console.inkey` even during automated tests or multiplayer coordinator simulation, which can throw when `console` is undefined. Several helper functions guard against missing console, but `handleInput` does not.
4. **Shot clock reset pause blocks frame scheduler.** When a shot-clock violation occurs, `runGameFrame` calls `systems.frameScheduler.waitForNextFrame(SHOT_CLOCK_RESET_PAUSE_MS)`, which is effectively `mswait(1000)` and halts AI/input processing. That pause also runs inside multiplayer coordinator loops, delaying state updates and potentially causing clients to time out.
5. **Jump indicator cleanup relies on global `sprite.jumpIndicatorData`.** If a sprite reference is removed (e.g., due to lagged multiplayer desync) without calling `clearJumpIndicator`, stale entries can remain in memory and never be restored, causing the overlay to accumulate invisible “ghost” records.
6. **`mp_client.js` collision guard ignores updated physics.** The client prediction still uses the legacy “dx < 1.5 && dy < 1.5” test even though `movement-physics.js` now allows smaller hitboxes (2×2 core). Any change to the authoritative collision threshold requires a manual update in the prediction helper.
7. **Violation inbound assumes two players per team.** `setupViolationInbound` selects `teamPlayers[1 - inboundIndex]` as the receiver. If roster data ever shrinks to a single sprite (debug scenarios, practice mode), receiver falls back to inbounder and the inbound script may try to pass to itself, leading to stuck possessions.
8. **Scoreboard redraw frequency tied to render throttle.** The scoreboard shares the same `COURT_RENDER_THROTTLE_MS` (60 ms) as the court. Heavy scenes that set `courtNeedsRedraw = false` can starve the scoreboard from updating (e.g., turbo meters) until any dirtied court cell is detected.
9. **Multiplayer queue creation assumes synchronized metadata.** In `mp_coordinator.js`, `this.session.playerList` is read before `this.session` is guaranteed to exist. If a lobby bug leaves `playerList` unset, the coordinator never creates queues and silently fails to collect inputs.
10. **Playoff scheduling may not reschedule when availability changes.** When a player updates their availability via `showAvailabilitySettings()`, the `setAvailability()` call stores the new blocks but does not automatically trigger `rescheduleMatch()` for any existing unscheduled matches. The user sees "No overlapping availability found" but changing availability doesn't immediately re-check for overlap. **Future work:** Add "active scheduling" where users can view opponent's schedule and manually pick time slots, or auto-reschedule on availability update.
